<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Prologue by HTML5 UP</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="../../assets/css/main.css" />
</head>

<body class="is-preload">

	<!-- Header -->
	<div id="header">

		<div class="top">

			<!-- Logo -->
			<div id="logo">
				<span class="image avatar48"><img src="images/avatar.jpg" alt="" /></span>
				<h1 id="title">Jane Doe</h1>
				<p>Hyperspace Engineer</p>
			</div>

			<!-- Nav -->
			<nav id="nav">
				<ul>
					<li><a href="#top" id="top-link"><span class="icon solid fa-home">Intro</span></a></li>
					<li><a href="#portfolio" id="portfolio-link"><span class="icon solid fa-th">Portfolio</span></a>
					</li>
					<li><a href="#about" id="about-link"><span class="icon solid fa-user">About Me</span></a></li>
					<li><a href="#contact" id="contact-link"><span class="icon solid fa-envelope">Contact</span></a>
					</li>
				</ul>
			</nav>

		</div>

		<div class="bottom">

			<!-- Social Icons -->
			<ul class="icons">
				<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
				<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
				<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
				<li><a href="#" class="icon brands fa-dribbble"><span class="label">Dribbble</span></a></li>
				<li><a href="#" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
			</ul>

		</div>

	</div>

	<!-- Main -->
	<div id="main">

		<!-- Intro -->
		<section id="top" class="one dark cover">
			<div class="container">

				<header>
					<h2 class="alt">垃圾回收机制</h2>
					<p></p>
				</header>
				<div>

					1.js的垃圾回收机制是什么原理：

					各大浏览器通常采用的垃圾回收机制有两种方式：

					1.标记清除：

					    javascript最常用的垃圾回收方式。 垃圾回收器在运行时，会给内存中的所有变量都加上标记，然后，去掉在环境中变量的标记。
					然后在标记的变量就是准备清除的变量，最后，垃圾回收器销毁带标记的变量，并回收他们的内存。

					2.引用计数：ie

					    当声明了一个变量，并将一个引用类型赋值给该变量时，这个值的引用次数就加一。如果该变量又引用其他值，则该值的引用次数减一。

					缺点时，相互引用的情况下，会出现内存泄漏问题。

					var element = document.getElementById("some_element");
					var myObj =new Object();
					myObj.element = element;
					element.someObject = myObj;
					2.减少javascript中的垃圾回收的方法：

					A.尽量少使用new语句。

					  new关键字意味着一次内存分配。在后续过程中，尽量多的重用这些创建好的对象。

					  {}.   [].    function(){} 也会分配内存。

					B.对象object优化

					  用{ }新建对象，常常作为返回值使用，导致过多的内存创建。 应该定义个全局对象， 每次函数调用，将返回数据放入到全局对象中，并返回此全局对象。

					// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！

					cr.wipe = function (obj) {
					    for (var p in obj) {
					         if (obj.hasOwnProperty(p))
					            delete obj[p];
					    }
					};
					使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！

					C。数组array的优化

					将[]赋值给一个数组对象，是清空数组的捷径（例如： arr =
					[];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length =
					0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

					D。 方法function优化

					setTimeout(

					    (function(self) {                    

					      return function () {

					              self.tick();

					    };

					})(this), 16)

					每一次调用，都返回了一个新的方法对象，导致大量的方法对象垃圾。

					优化：

					this.tickFunc = ( function(self) {
					      return function() {
					                self.tick();
					      };
					    } )(this);
					// in the tick() function
					setTimeout(this.tickFunc, 16);
					内存泄露

					a.意外的全局变量引起的内存泄露

					原因: 全局变量不会被回收
					解决：使用严格模式避免

					b.闭包引起的

					原因: 活动对象被引用，使闭包内的变量不会被释放
					解决: 将活动对象赋值为null

					c.被清理的DOM元素的引用

					原因: 虽然DOM被删掉了，但对象中还存在对DOM的引用
					解决: 将对象赋值为null

					d.被遗忘的定时器或回调

					原因: 定时器内部实现闭包，回调也是闭包
					解决: 清理定时器clearInterval、null

					栈和堆的区别

					　　一、堆栈空间分配区别：

					　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

					　　2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

					　　二、堆栈缓存方式区别：

					　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

					　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

					　　三、堆栈数据结构区别：

					　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

					　　栈（数据结构）：一种先进后出的数据结构。

				</div>
				<footer>
					--
				</footer>
			</div>
		</section>

	</div>

	<!-- Footer -->
	<div id="footer"> </div>

	<!-- Scripts -->
	<script src="../../assets/js/jquery.min.js"></script>
	<script src="../../assets/js/jquery.scrolly.min.js"></script>
	<script src="../../assets/js/jquery.scrollex.min.js"></script>
	<script src="../../assets/js/browser.min.js"></script>
	<script src="../../assets/js/breakpoints.min.js"></script>
	<script src="../../assets/js/util.js"></script>
	<script src="../../assets/js/main.js"></script>

</body>

</html>