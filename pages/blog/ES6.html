<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Prologue by HTML5 UP</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="../../assets/css/main.css" />
</head>

<body class="is-preload">

	<!-- Header -->
	<div id="header">

		<div class="top">

			<!-- Logo -->
			<div id="logo">
				<span class="image avatar48"><img src="images/avatar.jpg" alt="" /></span>
				<h1 id="title">Jane Doe</h1>
				<p>Hyperspace Engineer</p>
			</div>

			<!-- Nav -->
			<nav id="nav">
				<ul>
					<li><a href="#top" id="top-link"><span class="icon solid fa-home">Intro</span></a></li>
					<li><a href="#portfolio" id="portfolio-link"><span class="icon solid fa-th">Portfolio</span></a>
					</li>
					<li><a href="#about" id="about-link"><span class="icon solid fa-user">About Me</span></a></li>
					<li><a href="#contact" id="contact-link"><span class="icon solid fa-envelope">Contact</span></a>
					</li>
				</ul>
			</nav>

		</div>

		<div class="bottom">

			<!-- Social Icons -->
			<ul class="icons">
				<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
				<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
				<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
				<li><a href="#" class="icon brands fa-dribbble"><span class="label">Dribbble</span></a></li>
				<li><a href="#" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
			</ul>

		</div>

	</div>

	<!-- Main -->
	<div id="main">

		<!-- Intro -->
		<section id="top" class="one dark cover">
			<div class="container">

				<header>
					<h2 class="alt">ES6</h2>
					<p></p>
				</header>
				<div>

					ES6声明变量的六种方式：
					1。var
					2。function
					3。let
					4。const
					5。import
					6。class

					let:
					1. let声明的变量，在代码块内有效。
					2.  let声明的变量不能重复声明
					3. 不存在变量提升
					4.  暂时性死区


					其他知识点讲解：
					1.变量提升：
					    指的是，用var定义一个变量时，可以在变量声明之前使用。值为undefined;
					    明显不符合一般逻辑。所有，let禁止这种情况。
					2.暂时性死区：
					     var i =1;
					     if(true){
					         i = 333;
					         let i;
					    }
					如上，有全局变量i,但是在块级作用域中又声明了一个变量i，ES6规定，区块中又lwt命令，则对整个区块形成封闭作用域，在其之前使用这些变量就会报错，所以，定义变量一定要确定不会重复。
					3.块作用域：
					   es6之前，只有全局作用域和函数作用域，后加了块级作用域{}

					const 命令
					const声明一个只读的常量，一旦声明，值不能改变；
					声明常量，必须立即初始化，否则报错。


					-----------------------

					1.判断一个字符串中是否包含某字段字符串：
					原有 indexof() 方法，ES6新增三个方法：
					-- includes() ; 返回布尔值，表示是否找到了字符串。
					-- startsWith(); 返回布尔值，表示字符串是否以参数字符串开头。
					-- endsWith(); 返回布尔值，表示字符串是否以参数字符串结尾。

					let s = 'Hello world!';

					s.startsWith('Hello') // true
					s.endsWith('!') // true
					s.includes('o') // true
					2.repeat(number)  返回一个新的字符串，表示将原字符串重复n次。
					'hello'.repeat(2) // "hellohello"
					3.ES2017引入字符串补全功能
					padStart(长度，字符串), padEnd(长度，字符串)
					某个字符串不够指定长度，会在头部 or 尾部补全

					'x'.padStart(5, 'ab') // 'ababx'
					'x'.padStart(4, 'ab') // 'abax'

					'x'.padEnd(5, 'ab') // 'xabab'
					'x'.padEnd(4, 'ab') // 'xaba'
					常用用途： 1.补全制定位数，2。提示字符串格式

					'12'.padStart(10, '0') // "0000000012"
					'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
					4. matchAll()  返回正则表达式在当前字符串的匹配
					here is a link ~ 正则扩展

					5.模版字符串 反引号


					只列出常用的几个，模版字符串实践后更新具体感受。。



					-----------Symbol------------

					es6使用Symbol的目的：
					   使用别人提供的对象，但是又想自己增加属性，为了防止属性名的冲突；
					Symbol  es6引入的第七种数据类型
					每一个Symbol的返回值都是不相等的

					2。Symbol作为属性名
					let mySymbol = Symbol(); // A

					// 第一种写法
					let a = {};
					a[mySymbol] = 'mySymbol对象!';

					// 第二种写法 C
					let a = {
					[mySymbol]: 'mySymbol对象!'
					};

					// 第三种写法
					let a = {};
					Object.defineProperty(a, mySymbol, {value:'mySymbol对象!'});

					// 以上写法都得到同样结果
					a[mySymbol] // "mySymbol对象!"

					a.mySymbol = 'Hello!';
					a[mySymbol] //"mySymbol对象!" B
					a['mySymbol'] // "Hello!"
					注意：  A：Symbol不能使用new新建；
					              B:   Symbol 值作为对象属性名时，不能用点运算符
					              C:   Symbol 值作为对象属性名时，Symbol 值必须放在方括号之中。

					例子： 下面这个例子，还是没有get到symbol非用不可的好处！！！

					let a = {};
					let a = {};
					a.name = "json"; //普通方式
					let size = Symbol(); //利用symbol增加
					a[size] = "12";
					console.log(a);
					console.log(a.name);
					console.log(a[size]);
					想了下，继续修改： 我们假设a是个共用的对象，我们想给a加一个属性，我们使用，但是又怕别人也想加自己的属性，造成和自己的重名。  这时候就可以使用symbol();
					下面两块代码分别为不同用户的代码。他们都给a增加了size属性，他们也只能拿到自己增加的size，其他用户增加的他是拿不到的。

					let a = {};
					let a = {};
					a.size = "json";
					function setSize(s){
					let size = Symbol();  
					a[size] = s;
					console.log(a);
					console.log(a[size]); 
					}
					setSize(12);

					function setSize(s){
					let size = Symbol();  
					a[size] = s;
					console.log(a);
					console.log(a[size]); 
					}
					setSize(23);


					-----------------------


					Set数据结构， 没有重复的值。

					利用set去重数组 

					let arr = [1, 2, 3, 4, 4, 5, 5];
					const set = new Set(arr);
					let newArr = [...set]; // [1, 2, 3, 4, 5]
					去重字符串里面的 重复字符

					[...new Set('ababbc')].join(''); // "abc"
					set的属性和方法：
					属性：
					Set.prototype.constructor   构造函数，默认就是set函数
					Set.prototype.size    返回set实例的成员总数
					方法：
					- add(value) ;   // 添加一个值，返回 set结构本身
					- delete(value);  // 删除一个值，返回true，false，表示删除成功失败
					- has(value);  // 返回布尔值，确认 该值 是否是set的成员
					- clear();  // 清除所有成员，无返回值；

					遍历操作：

					- keys();  返回 键名 的遍历器
					- values(); 返回 键值 的遍历器
					- entries(); 返回 键值对 的遍历器
					- forEach(); 使用回调函数遍历每个成员

					Set的遍历顺序就是插入顺序

					*注 ： 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值，这种说法更靠谱），所以keys方法和values方法的行为完全一致。

					let set = new Set(['aa','bb','cc','dd']);
					for (let item of set.entries()) {
					console.log(item);
					}
					//['aa','aa']
					//['bb','bb']
					//['cc','cc']
					//['dd','dd']
					forEach()和数组相同，很不错

					set.forEach((value, key) => console.log(key +':'+ value))


					WeakSet
					WeakSet与Set的区别：
					1. WeakSet的成员只能是对象。 否则add(value)时候就报错



					Map
					方法：
					- set(xx , yy );    // 添加一个成员
					- get(xx);   // 根据key，获得对应的键值
					- delete(xx);  // 根据key，删除对应键值
					- has(xx);  // 判断map中是否有这个key
					- clear();  // 清除map的所有成员

					Map 的遍历顺序就是插入顺序。

					keys()：返回键名的遍历器。
					values()：返回键值的遍历器。
					entries()：返回所有成员的遍历器。
					forEach()：遍历 Map 的所有成员。


					WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名。

					能够解决内存泄漏 

					WeakMap只有四个方法可用：get()、set()、has()、delete()。

					let myElement = document.getElementById('logo');
					let myWeakmap = new WeakMap();

					myWeakmap.set(myElement, {timesClicked: 0});

					myElement.addEventListener('click', function() {
					let logoData = myWeakmap.get(myElement);
					logoData.timesClicked++;
					}, false);
					上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM
					节点删除，该状态就会自动消失，不存在内存泄漏风险。



					-----------------------

					RegExp构造函数

					字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。

					-----------------------

					1.数组的解构赋值
					2.对象的解构赋值
					3.字符串的解构赋值

					1.数组的解构赋值
					let [a,b,c] = [1,2,3];
					如上，可以从数组中提取值，按照对应位置，对变量赋值。

					let [foo, [[bar], baz]] = [1, [[2], 3]];
					//foo=1 bar=2 baz=3
					let [ , , third] = ["foo", "bar", "baz"];
					//third="baz"
					let [x, , y] = [1, 2, 3];
					//x=1 y=3
					let [head, ...tail] = [1, 2, 3, 4];
					//head=1 tail=[2, 3, 4]
					let [x, y, ...z] = ['a'];
					//x="a" y=undefined z=[]
					<1> 如果解构失败，变量的值就为undefined;
						<2> 如果，等号右侧不是数组（不是可遍历结构), 会报错 如： let [foo] = 1; //报错
							<3> let [x,y,z] = new Set(['a','b','c']);  //这样是可以的。因为其有Iterator接口。
								<4> 解构赋值允许指定默认值， let [foo='a'] = [];  foo=a 这样也是可以的,注意！只有         
									数组成员严格等于undefined，默认值才会生效。 let [a = 1] = [undefined ]//a=1
									<5> 默认值可以为表达式 function fun(){ return 12; }  let [a=fun()] = [1];  等价于下：
										let x;  if ([12][0] === undefined) {  x = f();   } else {   x = [12][0];  }
										 [12][0] 这种写法，意思是前面数组的第0个元素

										2.对象的解构赋值
										let { aaa, bbb } = { aaa:"first", bbb:"second"};  //结果：aaa=first, bbb=second
										变量必须与属性同名，才能取到正确的值
										如果变量名和属性名不一致，必须如下写：
										let obj = { first: 'hello', last: 'world' };  let { first: f, last: l } = obj;
										结果是 :f=hello ; l=world  前面属性的值赋值给后者
										对象解构赋值也可用用于嵌套的对象，一层层分析就好~

										let arr = [1, 2, 3];
										let {0 : first, [arr.length - 1] : last} = arr;
										first // 1
										last // 3
										3. 字符串的解构赋值
										字符串被转换成了一个类似数组的对象。
										类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

										const [a, b, c, d, e] = 'hello';
										//a="h" b="e" c="l" d="l" e="o"
										let { length:len }= 'hello'; // len=5
										4.数值和布尔值的解构赋值
										会先转为对象，再赋值。
										解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
										undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

										let {toString: s} = 123;
										s === Number.prototype.toString // true

										let {toString: s} = true;
										s === Boolean.prototype.toString // true 暂未体会到这个的用处
										5.函数参数的解构赋值
										function add([x, y]){
										return x + y;
										}
										add([1, 2]); // 3
										函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y

										function move({x, y} = { x: 0, y: 0 }) {
										return [x, y];
										}

										move({x: 3, y: 8}); // [3, 8]
										move({x: 3}); // [3, undefined] 并未触发 y的默认值
										move({}); // [undefined, undefined] 并未触发xy的默认值
										move(); // [0, 0]
										undefined 才会触发函数参数的默认值

										[1, undefined, 3].map((x = 'yes') => x);
										// [ 1, 'yes', 3 ]
										尽量不要使用圆括号

										解构赋值的用途
										1.交换变量值

										let x = 1;
										let y = 2;
										[x, y] = [y, x];
										2.从函数返回多个值

										// 返回一个数组
										function example() {
										return [1, 2, 3];
										}
										let [a, b, c] = example();

										// 返回一个对象
										function example() {
										return {
										foo: 1,
										bar: 2
										};
										}
										let { foo, bar } = example();
										3.函数参数的定义

										参数与变量名对应起来。。

										// 参数是一组有次序的值
										function f([x, y, z]) { ... }
										f([1, 2, 3]);

										// 参数是一组无次序的值
										function f({x, y, z}) { ... }
										f({z: 3, y: 2, x: 1});
										4.提取JSON数据    这个重要！！  可以快速提取 JSON 数据的值。

										let jsonData = {
										id: 42,
										status: "OK",
										data: [867, 5309]
										};

										let { id, status, data: number } = jsonData;

										console.log(id, status, number);
										// 42, "OK", [867, 5309]
										5.函数参数的默认值

										函数参数可以写成 数组，或者 json，直接可以使用里面的key，不用获取！！

										function testsf({aa="aaa",bb="bbb"}){
										console.log(aa);
										console.log(bb);
										}

										//testsf("hh");

										var conf = {bb:"hh",aa:"cc"};
										testsf(conf);
										// 42, "OK", [867, 5309]
										function testsf([aa="aaa",bb="bbb"]){
										console.log(aa);
										console.log(bb);
										}

										//testsf("hh");

										testsf(["hh","cc"]);
										6. 遍历Map结构

										使用for...of 循环遍历；  跳转：（for..of 与 for...in 的区别理解）

										在这简单列出例子，跳转的 for..of 与 for...in 的区别理解 详细使用代码例子进行介绍

										let map = new Map();
										map.set('first', 'hello');
										map.set('second', 'world');

										for (let [key, value] of map) {
										console.log(key + " is " + value);
										}

										// 获取键名
										for (let [key] of map) {

										}

										// 获取键值
										for (let [,value] of map) {

										}
										（7）输入模块的指定方法

										加载模块时，可以如下写，引入多个方法。

										const { First, Second } = require("FSMethod");




				</div>
				<footer>
					--
				</footer>
			</div>
		</section>

	</div>

	<!-- Footer -->
	<div id="footer"> </div>

	<!-- Scripts -->
	<script src="../../assets/js/jquery.min.js"></script>
	<script src="../../assets/js/jquery.scrolly.min.js"></script>
	<script src="../../assets/js/jquery.scrollex.min.js"></script>
	<script src="../../assets/js/browser.min.js"></script>
	<script src="../../assets/js/breakpoints.min.js"></script>
	<script src="../../assets/js/util.js"></script>
	<script src="../../assets/js/main.js"></script>

</body>

</html>